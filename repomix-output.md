This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-01-06T04:38:40.322Z

# File Summary

## Purpose
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

## File Format
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A header with the file path (## File: path/to/file)
  b. The full contents of the file in a code block

## Usage Guidelines
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

## Notes
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

## Additional Info

# Directory Structure
```
tests/
  background.test.js
  contentScript.test.js
  logger.test.js
.gitignore
babel.config.js
background.js
contentScript.js
jest.setup.js
logger.js
manifest.json
package.json
popup.html
popup.js
README.md
test_parser.js
```

# Files

## File: tests/background.test.js
```javascript
/**
 * @file tests/background.test.js
 */

describe('background.js - Unit Tests', () => {
  let backgroundMessageHandler = null;
  let logs;

  beforeEach(() => {
    // Reset the chrome mock before each test
    global.chrome = {
      runtime: {
        onMessage: {
          addListener: jest.fn((handler) => {
            // Store the handler so we can call it in tests
            backgroundMessageHandler = handler;
          })
        },
        lastError: null
      },
      storage: {
        local: {
          get: jest.fn(),
          set: jest.fn()
        }
      }
    };

    // Import background.js after setting up mocks
    jest.isolateModules(() => {
      require('../background.js');
      const logger = require('../logger.js');
      logs = logger.logs;
    });

    // Ensure handler was set
    expect(backgroundMessageHandler).toBeTruthy();
  });

  afterEach(() => {
    jest.clearAllMocks();
    delete global.chrome;
    backgroundMessageHandler = null;
  });

  it('registers a message listener on load', () => {
    expect(chrome.runtime.onMessage.addListener).toHaveBeenCalledTimes(1);
    expect(typeof backgroundMessageHandler).toBe('function');
  });

  it('handles RECIPE_DATA message by setting lastRecipeData', () => {
    const sendResponse = jest.fn();
    const message = {
      type: 'RECIPE_DATA',
      payload: { title: 'A New Recipe' }
    };
    
    backgroundMessageHandler(message, {}, sendResponse);
    expect(sendResponse).toHaveBeenCalledWith({ success: true });
  });

  it('handles unknown message types gracefully', () => {
    const sendResponse = jest.fn();
    const message = {
      type: 'UNKNOWN_TYPE',
      payload: {}
    };
    
    backgroundMessageHandler(message, {}, sendResponse);
    expect(sendResponse).toHaveBeenCalledWith({ error: 'Unknown message type' });
  });

  it('returns logs on GET_LOGS', () => {
    const sendResponse = jest.fn();
    backgroundMessageHandler({ type: 'GET_LOGS' }, {}, sendResponse);
    expect(sendResponse).toHaveBeenCalledWith({ logs });
  });

  it('handles LOG messages by calling logger methods', () => {
    const sendResponse = jest.fn();
    backgroundMessageHandler(
      { type: 'LOG', level: 'info', data: 'Some log info' },
      {},
      sendResponse
    );
    expect(sendResponse).toHaveBeenCalledWith({ success: true });
  });
});
```

## File: tests/contentScript.test.js
```javascript
/**
 * @file tests/contentScript.test.js
 */

describe('contentScript.js - Unit Tests', () => {
  let isRecipe, convertRecipeToPlainText;

  beforeEach(() => {
    // Reset chrome mock before each test
    global.chrome = {
      runtime: {
        sendMessage: jest.fn((message, callback) => {
          if (callback) callback({ success: true });
        }),
      }
    };

    // Set up jsdom
    document.body.innerHTML = '';

    // Import contentScript after setting up mocks
    jest.isolateModules(() => {
      const contentScript = require('../contentScript.js');
      isRecipe = contentScript.isRecipe;
      convertRecipeToPlainText = contentScript.convertRecipeToPlainText;
    });
  });

  afterEach(() => {
    jest.clearAllMocks();
    delete global.chrome;
    document.body.innerHTML = '';
  });

  describe('isRecipe()', () => {
    it('returns true for @type = Recipe', () => {
      expect(isRecipe({ '@type': 'Recipe' })).toBe(true);
    });

    it('returns true for an array containing "Recipe"', () => {
      expect(isRecipe({ '@type': ['Thing', 'Recipe'] })).toBe(true);
    });

    it('returns false if not a recipe', () => {
      expect(isRecipe({ '@type': 'Article' })).toBe(false);
      expect(isRecipe({})).toBe(false);
      expect(isRecipe(null)).toBe(false);
    });
  });

  describe('convertRecipeToPlainText()', () => {
    it('returns plain text using .name if present', () => {
      const recipe = {
        name: 'My Sample Recipe',
        recipeIngredient: ['2 cups flour', '1 cup sugar'],
        recipeInstructions: [
          {
            '@type': 'HowToStep',
            text: 'Mix ingredients'
          }
        ]
      };
      const result = convertRecipeToPlainText(recipe);
      expect(result).toContain('My Sample Recipe');
      expect(result).toContain('2 cups flour');
      expect(result).toContain('Mix ingredients');
    });

    it('falls back to "Untitled Recipe" if no name/title', () => {
      const recipe = {
        recipeIngredient: ['2 cups flour'],
        recipeInstructions: [
          {
            '@type': 'HowToStep',
            text: 'Mix flour'
          }
        ]
      };
      const result = convertRecipeToPlainText(recipe);
      expect(result).toContain('Untitled Recipe');
      expect(result).toContain('2 cups flour');
      expect(result).toContain('Mix flour');
    });
  });

  describe('Script Injection (Integration-ish test)', () => {
    it('parses JSON-LD from the DOM and calls chrome.runtime.sendMessage for a valid recipe', () => {
      // Set up our document body
      document.body.innerHTML = `
        <script type="application/ld+json">
        {
          "@context": "https://schema.org/",
          "@type": "Recipe",
          "name": "Test Recipe",
          "recipeIngredient": ["Ingredient 1", "Ingredient 2"],
          "recipeInstructions": [
            {
              "@type": "HowToStep",
              "text": "Step 1"
            }
          ]
        }
        </script>
      `;

      // Import contentScript to trigger its initialization
      jest.isolateModules(() => {
        require('../contentScript.js');
      });

      // First message should be a LOG type with debug level
      expect(chrome.runtime.sendMessage.mock.calls[0][0]).toMatchObject({
        type: 'LOG',
        level: 'debug'
      });

      // Find the RECIPE_DATA message
      const recipeDataCall = chrome.runtime.sendMessage.mock.calls.find(
        call => call[0].type === 'RECIPE_DATA'
      );
      expect(recipeDataCall).toBeTruthy();
      expect(recipeDataCall[0]).toMatchObject({
        type: 'RECIPE_DATA',
        payload: expect.objectContaining({
          name: 'Test Recipe'
        })
      });
    });
  });
});
```

## File: tests/logger.test.js
```javascript
/**
 * @file tests/logger.test.js
 */

describe('logger.js - Basic Unit Tests', () => {
  let logs, LOG_LEVELS, debug, info, warn, error, setLogLevel;

  beforeEach(() => {
    // Reset the chrome mock before each test
    global.chrome = {
      storage: {
        local: {
          get: jest.fn((keys, cb) => cb({ logs: [] })),
          set: jest.fn()
        }
      }
    };

    // Import logger after setting up mocks
    jest.isolateModules(() => {
      const logger = require('../logger.js');
      logs = logger.logs;
      LOG_LEVELS = logger.LOG_LEVELS;
      debug = logger.debug;
      info = logger.info;
      warn = logger.warn;
      error = logger.error;
      setLogLevel = logger.setLogLevel;
    });

    // Clear the logs array manually
    logs.length = 0;
  });

  afterEach(() => {
    jest.clearAllMocks();
    delete global.chrome;
  });

  it('appends new log entries', () => {
    info('Test info message');
    expect(logs.length).toBe(1);
    expect(logs[0]).toMatchObject({
      level: 'INFO',
      message: 'Test info message'
    });
  });

  it('respects setLogLevel()', () => {
    setLogLevel(LOG_LEVELS.WARN); 
    info('This should not appear');
    warn('This is a warning');
    expect(logs.length).toBe(1);
    expect(logs[0].level).toBe('WARN');
  });

  it('truncates logs beyond MAX_LOGS', () => {
    // Let's say MAX_LOGS is 1000 in your code
    for (let i = 0; i < 1100; i++) {
      debug(`Message ${i}`);
    }
    expect(logs.length).toBeLessThanOrEqual(1000);
  });

  it('stores logs in chrome.storage.local', () => {
    // Call a log method
    debug('Test store');
    // Expect chrome.storage.local.set to be called
    expect(global.chrome.storage.local.set).toHaveBeenCalledTimes(1);
    const setCall = global.chrome.storage.local.set.mock.calls[0][0];
    expect(Object.keys(setCall)).toContain('logs');
    expect(setCall.logs[0].message).toBe('Test store');
  });
});
```

## File: .gitignore
```
node_modules/
dist/
build/

# Ignore files generated by create-react-app
build/static/js/main.*.hot-update.js       # Hot reloading
build/static/js/main.*.hot-update.js.map  # Hot reloading
```

## File: babel.config.js
```javascript
module.exports = {
  presets: [
    ['@babel/preset-env', {
      targets: {
        node: 'current'
      },
      modules: 'commonjs'
    }]
  ]
};
```

## File: background.js
```javascript
// background.js
// -------------------------------------------------------
// The background service worker for the extension.
// Responsibilities:
// 1. Listens for messages from content scripts / popup.
// 2. Stores the latest recipe data.
// 3. Maintains a log (via logger.js) that can be retrieved by the popup.
//
// -------------------------------------------------------

import {
  logs,
  debug,
  info,
  warn,
  error
} from './logger.js';

let lastRecipeData = null;

chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
  if (message.type === "RECIPE_DATA") {
    lastRecipeData = message.payload;
    info("Recipe data received in background script", lastRecipeData);
    sendResponse({ success: true });
    return true;
  } else if (message.type === "GET_LAST_RECIPE") {
    sendResponse({ recipeData: lastRecipeData });
    return true;
  } else if (message.type === "GET_LOGS") {
    sendResponse({ logs });
    return true;
  } else if (message.type === "LOG") {
    // Handle logs from content script
    switch (message.level) {
      case "debug":
        debug(message.data);
        break;
      case "info":
        info(message.data);
        break;
      case "warn":
        warn(message.data);
        break;
      case "error":
        error(message.data);
        break;
    }
    sendResponse({ success: true });
    return true;
  }
  
  // Handle unknown message types
  warn(`Received unknown message type: ${message.type}`);
  sendResponse({ error: 'Unknown message type' });
  return true;
});

chrome.runtime.onMessageExternal.addListener((request, sender, sendResponse) => {
  if (request.action === 'GET_RECIPE') {
    sendResponse({ recipe: lastRecipeData });
  }
});
```

## File: contentScript.js
```javascript
// contentScript.js
// -------------------------------------------------------
// Injected into webpages that match "<all_urls>" (per manifest).
// Attempts to find JSON-LD scripts containing recipe data.
// If found, it sends that data to the background script via "RECIPE_DATA".
//
// Also provides its own logging via messages of type "LOG" so that
// color-coded logs appear in the background script (logger.js).
// -------------------------------------------------------

/**
 * Helper function to send logs to the background script,
 * which then uses logger.js for color-coded, level-based logs.
 */
function log(level, data) {
  chrome.runtime.sendMessage({ type: "LOG", level, data });
}

/**
 * Check if an object qualifies as a "Recipe".
 * Some recipes have "@type" = "Recipe", others have an array for "@type" (e.g. ["Thing","Recipe"]).
 */
function isRecipe(obj) {
  if (!obj || !obj['@type']) return false;
  const type = obj['@type'];
  return type === 'Recipe' || (Array.isArray(type) && type.includes('Recipe'));
}

/**
 * Extract instructions from a recipe object in a consistent, readable way.
 */
function extractInstructions(recipeData) {
  const instructions = recipeData.recipeInstructions;
  if (!instructions) return [];

  // Handle array of strings
  if (Array.isArray(instructions) && typeof instructions[0] === 'string') {
    return instructions;
  }

  // Handle array of HowToSection objects
  if (Array.isArray(instructions) && instructions[0]['@type'] === 'HowToSection') {
    return instructions
      .filter(section => section.name === 'Recipe Instructions')
      .flatMap(section => section.itemListElement)
      .map(step => step.text)
      .filter(text => text); // Remove any undefined or empty strings
  }

  // Handle single HowToSection object
  if (typeof instructions === 'object' && instructions['@type'] === 'HowToSection') {
    return instructions.itemListElement
      .map(step => step.text)
      .filter(text => text);
  }

  // Handle array of HowToStep objects directly
  if (Array.isArray(instructions) && instructions[0]['@type'] === 'HowToStep') {
    return instructions
      .map(step => step.text)
      .filter(text => text);
  }

  // Handle single string
  if (typeof instructions === 'string') {
    return [instructions];
  }

  return [];
}

/**
 * Extract ingredients from a recipe object, handling various formats.
 */
function extractIngredients(recipeData) {
  const ingredients = recipeData.recipeIngredient;
  if (!ingredients) return [];

  // Handle array of ingredients
  if (Array.isArray(ingredients)) {
    return ingredients;
  }

  // Handle single string
  if (typeof ingredients === 'string') {
    return [ingredients];
  }

  return [];
}

/**
 * Convert a recipe object into the desired plain-text output format.
 * 
 * @param {Object} recipe - The recipe object containing title, ingredients, and instructions
 * @returns {string} A single string containing the desired output format
 */
function convertRecipeToPlainText(recipe) {
  const title = recipe.name || 'Untitled Recipe';
  const ingredients = extractIngredients(recipe);
  const instructions = extractInstructions(recipe);
  
  let output = title + '\n\n';
  
  if (ingredients.length > 0) {
    output += 'Ingredients:\n';
    ingredients.forEach((ingredient, index) => {
      output += `${index + 1}. ${ingredient}\n`;
    });
    output += '\n';
  }
  
  if (instructions.length > 0) {
    output += 'Instructions:\n';
    instructions.forEach((instruction, index) => {
      output += `${index + 1}. ${instruction}\n`;
    });
  }
  
  return output;
}

// Main content script functionality
function init() {
  log("debug", "Content script loaded. Searching for recipe JSON-LD...");

  // Find all script elements
  const scripts = document.querySelectorAll('script[type="application/ld+json"]');
  
  scripts.forEach(script => {
    try {
      const data = JSON.parse(script.textContent);
      
      // Handle both single objects and arrays of objects
      const recipes = Array.isArray(data) ? data : [data];
      
      recipes.forEach(item => {
        if (isRecipe(item)) {
          log("info", "Found recipe data:", item);
          
          // Send to background script
          chrome.runtime.sendMessage({
            type: "RECIPE_DATA",
            payload: item
          });

          // Convert to plain text and log it
          const plainTextOutput = convertRecipeToPlainText(item);
          log("info", "Desired Output:\n" + plainTextOutput);
        }
      });
    } catch (e) {
      log("error", "Error parsing JSON-LD:", e.message);
    }
  });
}

// Run the content script
init();

// Export for testing
if (typeof module !== 'undefined' && module.exports) {
  module.exports = {
    isRecipe,
    convertRecipeToPlainText,
    extractInstructions,
    extractIngredients
  };
}
```

## File: jest.setup.js
```javascript
// Polyfill TextEncoder/TextDecoder if needed
if (typeof global.TextEncoder === 'undefined') {
  const { TextEncoder, TextDecoder } = require('util');
  global.TextEncoder = TextEncoder;
  global.TextDecoder = TextDecoder;
}

// Mock chrome.runtime API
global.chrome = {
  runtime: {
    sendMessage: jest.fn(),
    onMessage: {
      addListener: jest.fn()
    },
    lastError: null
  },
  storage: {
    local: {
      get: jest.fn(),
      set: jest.fn()
    }
  }
};
```

## File: logger.js
```javascript
// logger.js
// -------------------------------------------------------
// A small utility for controlling log levels, color-coding them in the console,
// and storing them in memory so the popup can display them.
//
// You can adjust "currentLogLevel" to control verbosity. In production, you
// might set it to LOG_LEVELS.INFO or LOG_LEVELS.ERROR to reduce noise.
//
// Supports "pretty printing" for objects (JSON.stringify(..., null, 2)).
//
// -------------------------------------------------------

const LOG_LEVELS = {
  NONE: 0,
  ERROR: 1,
  WARN: 2,
  INFO: 3,
  DEBUG: 4
};

// Adjust this to the desired minimum level of logs:
let currentLogLevel = LOG_LEVELS.DEBUG;

/**
 * Sets the current log level globally (if you want to change it at runtime).
 * @param {number} level - Must be one of LOG_LEVELS.DEBUG, LOG_LEVELS.INFO, etc.
 */
function setLogLevel(level) {
  if (Object.values(LOG_LEVELS).includes(level)) {
    currentLogLevel = level;
  }
}

/**
 * We store logs both in memory and chrome.storage.local
 */
const logs = [];

// Load existing logs from storage when the module initializes
chrome.storage.local.get(['logs'], (result) => {
  if (result.logs) {
    logs.push(...result.logs);
  }
});

// Maximum number of logs to keep
const MAX_LOGS = 1000;

/**
 * A helper to get CSS styles for each log level (for color-coded console output).
 */
function getConsoleStyle(levelName) {
  const styles = {
    DEBUG: 'color: #6c757d',
    INFO: 'color: #0d6efd',
    WARN: 'color: #ffc107',
    ERROR: 'color: #dc3545'
  };
  return styles[levelName] || '';
}

/**
 * Master function that handles all logs. It:
 * 1. Checks the log level vs. currentLogLevel
 * 2. Color-codes logs in the console
 * 3. Pretty-prints objects
 * 4. Stores logs in both memory and chrome.storage.local
 */
function logMessage(level, ...args) {
  if (level > currentLogLevel) return;

  const levelName = Object.keys(LOG_LEVELS).find(key => LOG_LEVELS[key] === level);
  const timestamp = new Date().toISOString();
  
  // Format the message
  const formattedArgs = args.map(arg => {
    if (arg === undefined) return 'undefined';
    if (arg === null) return 'null';
    if (typeof arg === 'object') {
      try {
        return JSON.stringify(arg, null, 2);
      } catch (e) {
        return '[Object]';
      }
    }
    return String(arg);
  });
  
  // Create log entry
  const logEntry = {
    level: levelName,
    timestamp,
    message: formattedArgs.join(' ')
  };

  // Add to memory array
  logs.unshift(logEntry);
  
  // Trim logs if they exceed MAX_LOGS
  if (logs.length > MAX_LOGS) {
    logs.length = MAX_LOGS;
  }

  // Save to storage
  chrome.storage.local.set({ logs });

  // Console output with color
  console.log(
    `%c[${levelName}] ${timestamp}:`,
    getConsoleStyle(levelName),
    ...formattedArgs
  );
}

// Export convenience functions for each log level
function debug(...args) {
  logMessage(LOG_LEVELS.DEBUG, ...args);
}

function info(...args) {
  logMessage(LOG_LEVELS.INFO, ...args);
}

function warn(...args) {
  logMessage(LOG_LEVELS.WARN, ...args);
}

function error(...args) {
  logMessage(LOG_LEVELS.ERROR, ...args);
}

export {
  LOG_LEVELS,
  logs,
  setLogLevel,
  debug,
  info,
  warn,
  error
};
```

## File: manifest.json
```json
{
  "name": "Yes Chef",
  "version": "1.0",
  "manifest_version": 3,
  "description": "Scrapes recipe data from the current webpage, with color-coded logs and a debug panel.",
  "permissions": [
    "activeTab",
    "scripting",
    "storage"
  ],
  "background": {
    "service_worker": "background.js",
    "type": "module"
  },
  "content_scripts": [
    {
      "matches": ["<all_urls>"],
      "js": ["contentScript.js"],
      "type": "module"
    }
  ],
  "action": {
    "default_title": "Yes Chef",
    "default_popup": "popup.html"
  },
  "externally_connectable": {
    "matches": [
      "*://localhost/*",
      "*://yeschef.ai/*"
    ]
  }
}
```

## File: package.json
```json
{
  "name": "yes-chef-browser-extension",
  "version": "1.0.0",
  "description": "Browser extension for extracting recipes from JSON-LD",
  "main": "background.js",
  "scripts": {
    "test": "jest",
    "test:watch": "jest --watch"
  },
  "devDependencies": {
    "@babel/core": "^7.23.7",
    "@babel/preset-env": "^7.23.7",
    "babel-jest": "^29.7.0",
    "jest": "^29.7.0",
    "jest-environment-jsdom": "^29.7.0"
  },
  "jest": {
    "testEnvironment": "jsdom",
    "setupFiles": ["./jest.setup.js"],
    "transform": {
      "^.+\\.jsx?$": "babel-jest"
    },
    "moduleFileExtensions": ["js", "json", "jsx", "node"],
    "transformIgnorePatterns": [
      "/node_modules/(?!(@babel/runtime)/)"
    ],
    "testMatch": [
      "**/tests/**/*.test.js"
    ]
  }
}
```

## File: popup.html
```html
<!DOCTYPE html>
<html>
  <head>
    <title>Recipe Scraper</title>
    <style>
      body {
        font-family: system-ui, -apple-system, sans-serif;
        margin: 1em;
        width: 500px;
        max-width: 100%;
      }
      
      #recipe-info {
        white-space: pre-wrap;
        font-family: monospace;
        background: #f8f9fa;
        padding: 1em;
        border-radius: 4px;
        border: 1px solid #dee2e6;
      }
      
      #debug-logs {
        width: 100%;
        height: 300px;
        font-family: monospace;
        display: none;
        margin-top: 1em;
        background: #212529;
        color: #f8f9fa;
        border: none;
        padding: 1em;
        border-radius: 4px;
      }
      
      #debug-controls {
        margin-top: 1em;
        display: flex;
        gap: 0.5em;
      }
      
      button {
        padding: 0.5em 1em;
        border: none;
        border-radius: 4px;
        background: #0d6efd;
        color: white;
        cursor: pointer;
      }
      
      button:hover {
        background: #0b5ed7;
      }
      
      .log-entry {
        margin-bottom: 0.5em;
        padding: 0.25em 0;
      }

      .log-timestamp {
        color: #6c757d;
        font-size: 0.9em;
      }

      .log-level {
        padding: 0.2em 0.4em;
        border-radius: 3px;
        margin: 0 0.5em;
        font-size: 0.9em;
      }

      .log-level-DEBUG { background: #6c757d; color: white; }
      .log-level-INFO { background: #0d6efd; color: white; }
      .log-level-WARN { background: #ffc107; color: black; }
      .log-level-ERROR { background: #dc3545; color: white; }

      .log-message {
        margin-left: 0.5em;
      }

      .log-message pre {
        margin: 0.5em 0 0.5em 1.5em;
        padding: 0.5em;
        background: #2c3338;
        border-radius: 3px;
      }
    </style>
  </head>
  <body>
    <h1>Recipe Scraper</h1>
    <!-- This div will display the most recently found recipe data. -->
    <div id="recipe-info">No recipe detected yet.</div>

    <!-- Debug panel controls -->
    <div id="debug-controls">
      <button id="toggle-debug">Toggle Debug Logs</button>
      <button id="refresh-logs">Refresh Logs</button>
    </div>

    <!-- A textarea that displays logs (hidden by default). -->
    <textarea id="debug-logs" readonly></textarea>

    <script src="popup.js"></script>
  </body>
</html>
```

## File: popup.js
```javascript
// popup.js
// -------------------------------------------------------
// This script runs in the popup. It:
// 1. Queries the background script for the most recent recipe data.
// 2. Allows toggling and refreshing of a debug logs area, which is fed
//    by the background script's in-memory log array.
//
// -------------------------------------------------------

document.addEventListener("DOMContentLoaded", async () => {
  const recipeInfoDiv = document.getElementById("recipe-info");
  const debugLogsTextArea = document.getElementById("debug-logs");
  const toggleDebugBtn = document.getElementById("toggle-debug");
  const refreshLogsBtn = document.getElementById("refresh-logs");

  // Add markdown-content class to recipe info div
  recipeInfoDiv.classList.add('markdown-content');

  // Fetch the last stored recipe from the background script
  chrome.runtime.sendMessage({ type: "GET_LAST_RECIPE" }, (response) => {
    if (response && response.recipeData) {
      // Display recipe data in a readable format
      const recipe = response.recipeData;
      let output = `${recipe.title}\n\n`;
      
      if (recipe.servings) {
        output += `Servings: ${Array.isArray(recipe.servings) 
          ? recipe.servings.filter(s => s !== null).join(", ") 
          : recipe.servings}\n\n`;
      }
      
      output += "Ingredients:\n";
      recipe.ingredients.forEach(ingredient => {
        output += `• ${ingredient.trim()}\n`;
      });
      output += "\n";
      
      output += "Instructions:\n";
      if (Array.isArray(recipe.instructions)) {
        const mainInstructions = recipe.instructions.find(
          section => section['@type'] === 'HowToSection' && 
                     section.name === 'Recipe Instructions'
        );
        
        if (mainInstructions && Array.isArray(mainInstructions.itemListElement)) {
          mainInstructions.itemListElement.forEach((step, index) => {
            if (step['@type'] === 'HowToStep' && step.text) {
              output += `${index + 1}. ${step.text}\n`;
            }
          });
        }
      }
      
      recipeInfoDiv.textContent = output;
    } else {
      recipeInfoDiv.textContent = "No recipe found. Visit a recipe page and try again.";
    }
  });

  // Show/hide logs
  let debugVisible = false;

  toggleDebugBtn.addEventListener("click", () => {
    debugVisible = !debugVisible;
    if (debugVisible) {
      debugLogsTextArea.style.display = "block";
      fetchLogs();
    } else {
      debugLogsTextArea.style.display = "none";
    }
  });

  // Refresh logs only if debug is visible
  refreshLogsBtn.addEventListener("click", () => {
    if (debugVisible) {
      fetchLogs();
    }
  });

  async function fetchLogs() {
    const debugLogsTextArea = document.getElementById("debug-logs");
    
    chrome.runtime.sendMessage({ type: "GET_LOGS" }, (response) => {
      if (response && response.logs) {
        const formattedLogs = response.logs.map(log => {
          const timestamp = new Date(log.timestamp).toLocaleTimeString();
          const isJson = log.message.trim().startsWith('{') || log.message.trim().startsWith('[');
          
          let formattedMessage = log.message;
          if (isJson) {
            try {
              const obj = JSON.parse(log.message);
              formattedMessage = `<pre>${JSON.stringify(obj, null, 2)}</pre>`;
            } catch (e) {
              // If JSON parsing fails, use the original message
            }
          }

          return `<div class="log-entry">
            <span class="log-timestamp">${timestamp}</span>
            <span class="log-level log-level-${log.level}">${log.level}</span>
            <span class="log-message">${formattedMessage}</span>
          </div>`;
        }).join('\n');

        debugLogsTextArea.innerHTML = formattedLogs;
      }
    });
  }
});
```

## File: README.md
```markdown
# yes-chef-browser-extension
```

## File: test_parser.js
```javascript
// Test parser for recipe conversion
const testRecipe = {
  "title": "Best Prime Rib",
  "ingredients": [
    "1 (7-pound), first-cut beef standing rib roast (3 bones), meat removed from bones, bones reserved",
    " , Kosher salt and ground black pepper ",
    "2 teaspoons, vegetable oil "
  ],
  "instructions": [
    {
      "@type": "HowToSection",
      "name": "Recipe Instructions",
      "position": "1",
      "itemListElement": [
        {
          "@type": "HowToStep",
          "text": "Look for a roast with an untrimmed fat cap (ideally ½ inch thick). We prefer the flavor and texture of prime-grade beef, but choice grade will work as well. To remove the bones from the roast, use a sharp knife and run it down the length of the bones, following the contours as closely as possible until the meat is separated. Monitoring the roast with a meat-probe thermometer is best. If you use an instant-read thermometer, open the oven door as little as possible and remove the roast from the oven while taking its temperature. If the roast has not reached the correct temperature in the time range specified in step 3, heat the oven to 200 degrees, wait for 5 minutes, then shut it off, and continue to cook the roast until it reaches the desired temperature."
        },
        {
          "@type": "HowToStep",
          "text": "Using sharp knife, cut slits in surface layer of fat, spaced 1 inch apart, in crosshatch pattern, being careful to cut down to, but not into, meat. Rub 2 tablespoons salt over entire roast and into slits. Place meat back on bones (to save space in refrigerator), transfer to large plate, and refrigerate, uncovered, at least 24 hours and up to 96 hours."
        },
        {
          "@type": "HowToStep",
          "text": "Adjust oven rack to middle position and heat oven to 200 degrees. Heat oil in 12-inch skillet over high heat until just smoking. Sear sides and top of roast (reserving bone) until browned, 6 to 8 minutes total (do not sear side where roast was cut from bone). Place meat back on ribs, so bones fit where they were cut, and let cool for 10 minutes; tie meat to bones with 2 lengths of twine between ribs. Transfer roast, fat side up, to wire rack set in rimmed baking sheet and season with pepper. Roast until meat registers 110 degrees, 3 to 4 hours."
        },
        {
          "@type": "HowToStep",
          "text": "Turn off oven; leave roast in oven, opening door as little as possible, until meat registers about 120 degrees for rare or about 125 degrees for medium-rare, 30 to 75 minutes longer."
        },
        {
          "@type": "HowToStep",
          "text": "Remove roast from oven (leave roast on baking sheet), tent loosely with aluminum foil, and let rest for at least 30 minutes and up to 75 minutes."
        },
        {
          "@type": "HowToStep",
          "text": "Adjust oven rack about 8 inches from broiler element and heat broiler. Remove foil from roast, form into 3-inch ball, and place under ribs to elevate fat cap. Broil until top of roast is well browned and crisp, 2 to 8 minutes."
        },
        {
          "@type": "HowToStep",
          "text": "Transfer roast to carving board; cut twine and remove roast from ribs. Slice meat into 3/4-inch-thick slices. Season with coarse salt to taste, and serve."
        }
      ]
    }
  ]
};

function convertRecipeToPlainText(recipe) {
  let output = '';
  
  // Title
  output += `${recipe.title}\n\n`;
  
  // Ingredients
  output += 'Ingredients\n';
  recipe.ingredients.forEach(ingredient => {
    // Clean up ingredient text
    const cleanIngredient = ingredient.trim().replace(/^,\s*/, '');
    if (cleanIngredient) {
      output += `${cleanIngredient}\n`;
    }
  });
  output += '\n';
  
  // Instructions
  output += 'Instructions\n';
  if (Array.isArray(recipe.instructions)) {
    // Find the main recipe instructions section
    const mainInstructions = recipe.instructions.find(
      section => section['@type'] === 'HowToSection' && 
                 section.name === 'Recipe Instructions'
    );
    
    if (mainInstructions && Array.isArray(mainInstructions.itemListElement)) {
      mainInstructions.itemListElement.forEach((step, index) => {
        if (step['@type'] === 'HowToStep' && step.text) {
          output += `${index + 1}. ${step.text}\n`;
        }
      });
    }
  }
  
  return output.trim();
}

// Run the test
console.log('Testing recipe conversion...\n');
console.log(convertRecipeToPlainText(testRecipe));
```
